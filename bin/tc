#!/usr/bin/env bash
# tc - theodore calvin's testing framework üöÅ
# language-agnostic test runner inspired by the helicopter pilot himself

set -e

# version info
TC_VERSION="1.0.0"
TC_CODENAME="island hopper"

# find tc root directory
TC_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# source core libraries
source "$TC_ROOT/lib/config/defaults.sh"
source "$TC_ROOT/lib/utils/log.sh"
source "$TC_ROOT/lib/utils/json.sh"
source "$TC_ROOT/lib/core/discovery.sh"
source "$TC_ROOT/lib/core/executor.sh"
source "$TC_ROOT/lib/utils/reporter.sh"

# show version
show_version() {
    echo "tc v${TC_VERSION} - ${TC_CODENAME}"
    echo "theodore calvin's language-agnostic testing framework"
    echo ""
    echo "üöÅ testing any language, anywhere"
}

# show help
show_help() {
    cat << 'EOF'
tc - theodore calvin's testing framework üöÅ

usage:
    tc run <suite-path>         run a single test suite
    tc run <path> --all         run all suites in directory tree
    tc --version                show version info
    tc --help                   show this help

examples:
    tc run ./tests/auth/login          # run one suite
    tc run ./tests --all               # run all suites
    tc run tests --all --parallel=4    # parallel execution

made with ‚òï and helicopters
EOF
}

# run command - execute test suite(s)
tc_run_command() {
    local suite_path="${1:-.}"
    local run_all=false

    # parse flags
    shift
    while [ $# -gt 0 ]; do
        case "$1" in
            --all)
                run_all=true
                shift
                ;;
            *)
                tc_error "unknown flag: $1"
                exit 1
                ;;
        esac
    done

    # check if jq is available
    if ! tc_check_jq; then
        exit 1
    fi

    # check if path exists
    if [ ! -e "$suite_path" ]; then
        tc_error "path not found: $suite_path"
        exit 1
    fi

    # run all suites in directory tree
    if [ "$run_all" = true ]; then
        tc_run_all_suites "$suite_path"
        exit $?
    fi

    # check if it's a test suite
    if tc_is_test_suite "$suite_path"; then
        tc_info "running suite: $suite_path"

        # execute suite
        local result=$(tc_execute_suite "$suite_path")
        local exit_code=$?

        # parse results (format: passed|failed|errors:::result_line1\nresult_line2\n...)
        local metadata="${result%%:::*}"
        local rest="${result#*:::}"

        IFS='|' read -r passed failed errors <<< "$metadata"

        # extract result details
        local results=()
        while IFS= read -r line; do
            [ -n "$line" ] && results+=("$line")
        done <<< "$rest"

        # report results
        tc_report_suite "$suite_path" "$passed" "$failed" "$errors" "${results[@]}"

        # write results to file
        tc_write_results "$suite_path" "${results[@]}"

        # exit with appropriate code
        exit $exit_code
    else
        tc_error "not a test suite: $suite_path"
        tc_error "test suites must have an executable 'run' file"
        exit 1
    fi
}

# run all test suites in directory tree
tc_run_all_suites() {
    local root_path="$1"

    tc_info "discovering test suites in: $root_path"

    # discover all suites
    local suites=$(tc_discover_suites_recursive "$root_path")
    local suite_count=$(echo "$suites" | wc -l)

    if [ -z "$suites" ]; then
        tc_error "no test suites found in: $root_path"
        exit 1
    fi

    tc_info "found $suite_count suite(s)"
    echo ""

    # aggregate results
    local total_passed=0
    local total_failed=0
    local total_errors=0
    local overall_exit=0

    # run each suite
    while read -r suite_dir; do
        [ -z "$suite_dir" ] && continue

        local suite_name=$(tc_suite_relative_path "$suite_dir" "$root_path")
        tc_info "running: $suite_name"

        # execute suite
        local result=$(tc_execute_suite "$suite_dir")
        local exit_code=$?

        # parse results
        local metadata="${result%%:::*}"
        local rest="${result#*:::}"
        IFS='|' read -r passed failed errors <<< "$metadata"

        # extract result details
        local results=()
        while IFS= read -r line; do
            [ -n "$line" ] && results+=("$line")
        done <<< "$rest"

        # report suite results
        tc_report_suite "$suite_dir" "$passed" "$failed" "$errors" "${results[@]}"

        # write results to file
        tc_write_results "$suite_dir" "${results[@]}"

        # aggregate
        total_passed=$((total_passed + passed))
        total_failed=$((total_failed + failed))
        total_errors=$((total_errors + errors))

        if [ $exit_code -ne 0 ]; then
            overall_exit=1
        fi

        echo ""
    done <<< "$suites"

    # print overall summary
    echo "===================================="
    echo "overall results"
    echo "===================================="
    echo ""
    echo "suites run: $suite_count"
    tc_report_summary "$total_passed" "$total_failed" "$total_errors"
    echo ""

    return $overall_exit
}

# main entry point
main() {
    case "${1:-}" in
        --version|-v)
            show_version
            ;;
        --help|-h|help)
            show_help
            ;;
        run)
            shift  # remove 'run' from args
            tc_run_command "$@"
            ;;
        *)
            show_help
            exit 1
            ;;
    esac
}

main "$@"
