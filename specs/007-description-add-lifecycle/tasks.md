# Implementation Tasks: Lifecycle Hooks and Stateful Test Runners

**Feature**: 007-description-add-lifecycle
**Branch**: `007-description-add-lifecycle`
**Date**: 2025-10-16

## Overview

Implementation plan for lifecycle hooks (setup/teardown/before_each/after_each) and stateful test runners. Tasks organized by user story for independent implementation and testing.

**Total Tasks**: 68
**Estimated Effort**: ~3-5 days
**MVP**: User Story 1 (Database Testing Pattern) - 24 tasks

---

## Task Summary by User Story

| User Story | Priority | Tasks | Status | Description |
|------------|----------|-------|--------|-------------|
| Setup | - | 4 tasks | Pending | Project initialization |
| Foundational | - | 12 tasks | Pending | Core infrastructure (blocking) |
| US1: Database Testing | P1 | 24 tasks | Pending | setup/teardown hooks (MVP) |
| US2: Stateful Runners | P1 | 16 tasks | Pending | Long-running runner protocol |
| US3: Per-Suite Hooks | P2 | 4 tasks | Pending | Hook validation & logging |
| US4: Global Hooks | P3 | 8 tasks | Pending | Global setup/teardown |
| Polish & Integration | - | 6 tasks | Pending | Documentation & testing |

---

## Phase 1: Setup (Project Initialization)

**Goal**: Create basic infrastructure for hooks module.

**Tasks**:

### T001: Create hooks module structure [P]
**File**: `tc/lib/core/hooks.sh`
**Description**: Create new hooks.sh module with file header, documentation, and module structure
**Dependencies**: None
**Output**: Empty hooks.sh with standard tc module header
```bash
#!/usr/bin/env bash
# tc/lib/core/hooks.sh - Lifecycle hooks management
# Provides hook discovery, validation, and execution for test suites
```

### T002: Add hook configuration defaults [P]
**File**: `tc/config/defaults.sh`
**Description**: Add hook-related configuration defaults
**Dependencies**: None
**Output**: Configuration variables added
```bash
# Hook configuration
TC_HOOK_TIMEOUT="${TC_HOOK_TIMEOUT:-30}"  # Default hook timeout (seconds)
TC_HOOKS_ENABLED="${TC_HOOKS_ENABLED:-true}"  # Enable/disable hooks globally
```

### T003: Source hooks module in main tc binary [P]
**File**: `bin/tc`
**Description**: Add hooks.sh to sourced modules list
**Dependencies**: T001
**Output**: Module sourced after discovery.sh
```bash
source "$TC_ROOT/lib/core/hooks.sh"
```

### T004: Add .tc-env to gitignore patterns
**File**: `.gitignore`
**Description**: Add .tc-env to gitignore (generated by hooks)
**Dependencies**: None
**Output**: `.tc-env` pattern added

---

## Phase 2: Foundational Tasks (Blocking Prerequisites)

**Goal**: Build core hook infrastructure needed by all user stories.

**These tasks MUST complete before any user story can be implemented.**

### T005: Implement hook file discovery [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_has_hook(suite_dir, hook_name)`
**Description**: Check if hook file exists and is executable
**Dependencies**: T001
**Logic**:
```bash
tc_has_hook() {
    local suite_dir="$1"
    local hook_name="$2"
    [ -f "$suite_dir/$hook_name.sh" ] && [ -x "$suite_dir/$hook_name.sh" ]
}
```

### T006: Implement global hook discovery [Story: Foundation] [P]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_has_global_hook(test_root, hook_name)`
**Description**: Check if global hook exists in tests/.tc/hooks/
**Dependencies**: T001
**Logic**: Check `$test_root/.tc/hooks/$hook_name.sh`

### T007: Implement hook validation [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_validate_hook(hook_file)`
**Description**: Validate hook file (regular file, executable, not symlink)
**Dependencies**: T005
**Validation Rules**:
- Must be regular file (`-f`)
- Must be executable (`-x`)
- Must not be symlink (`! -L`)
- Must have .sh extension

### T008: Implement hook execution wrapper [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_hook(suite_dir, hook_name, env_vars...)`
**Description**: Execute hook with timeout, error capture, environment setup
**Dependencies**: T007
**Features**:
- Set standard environment variables
- Capture stderr
- Apply timeout (TC_HOOK_TIMEOUT)
- Log execution with timing
- Return exit code

### T009: Implement environment variable setup [Story: Foundation] [P]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_set_hook_env(suite_dir, hook_type, scenario...)`
**Description**: Set standard environment variables for hooks
**Dependencies**: T001
**Variables**: TC_SUITE_PATH, TC_HOOK_TYPE, TC_ROOT, TC_SCENARIO, TC_DATA_DIR

### T010: Implement .tc-env file loader [Story: Foundation] [P]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_load_hook_env(suite_dir)`
**Description**: Source .tc-env file if exists
**Dependencies**: T001
**Logic**:
```bash
tc_load_hook_env() {
    local suite_dir="$1"
    [ -f "$suite_dir/.tc-env" ] && source "$suite_dir/.tc-env"
}
```

### T011: Implement hook logging [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_log_hook(hook_type, suite_dir, exit_code, duration_ms, stderr...)`
**Description**: Log hook execution to tc logging system
**Dependencies**: T008
**Log Format**: JSON with timestamp, hook_type, suite_path, duration_ms, exit_code, stderr

### T012: Implement hook failure behavior [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_handle_hook_failure(hook_type, exit_code, stderr)`
**Description**: Handle hook failures according to spec (abort, skip, warn, continue)
**Dependencies**: T008
**Behavior Matrix**:
- setup.sh fails → abort suite, return 1
- teardown.sh fails → log error, return 0 (continue)
- before_each.sh fails → skip scenario, continue to next
- after_each.sh fails → log warning, continue

### T013: Add hook mode detection [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_is_stateful_suite(suite_dir)`
**Description**: Detect if suite should run in stateful mode
**Dependencies**: T005
**Logic**: Return true if setup.sh exists

### T014: Implement hook execution order state machine [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_execute_suite_with_hooks(suite_dir)`
**Description**: Orchestrate hook execution order (skeleton only)
**Dependencies**: T008, T012
**Order**: setup → (before_each → scenario → after_each)* → teardown

### T015: Add hook execution to executor [Story: Foundation]
**File**: `tc/lib/core/executor.sh`
**Description**: Integrate tc_execute_suite_with_hooks into tc_execute_suite
**Dependencies**: T014
**Logic**: Detect hooks, delegate to hooks version if present

### T016: Implement trap for guaranteed teardown [Story: Foundation]
**File**: `tc/lib/core/hooks.sh`
**Description**: Use bash trap to ensure teardown runs even on failures
**Dependencies**: T014
**Logic**: `trap 'tc_run_hook "$suite_dir" "teardown"' EXIT`

---

## Phase 3: US1 - Database Testing Pattern (P1) 🎯 MVP

**User Story**: As a developer writing integration tests, I want to connect to a database once, then run all tests against it, so that my test suite doesn't waste 5 minutes connecting per test.

**Independent Test**: Create PostgreSQL test suite with setup.sh/teardown.sh, verify database connects once and all scenarios run against same connection.

**Acceptance Criteria**:
- ✅ Boot database connection once before all tests
- ✅ Clear and seed data before each test
- ✅ Run all tests against same connection
- ✅ Close connection after all tests
- ✅ Tests still isolated (clean data per test)

### T017: Implement setup.sh execution [Story: US1]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_setup(suite_dir)`
**Description**: Execute setup.sh hook with proper environment and error handling
**Dependencies**: T008, T009
**Logic**:
- Check if setup.sh exists
- Set TC_HOOK_TYPE=setup
- Run hook with timeout
- Handle failure (abort suite if fails)
- Log execution

### T018: Implement teardown.sh execution [Story: US1]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_teardown(suite_dir)`
**Description**: Execute teardown.sh hook (always runs, even on failures)
**Dependencies**: T008, T016
**Logic**:
- Load .tc-env if exists
- Set TC_HOOK_TYPE=teardown
- Run hook with timeout
- Log failure but don't abort (cleanup always continues)

### T019: Implement before_each.sh execution [Story: US1]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_before_each(suite_dir, scenario_name, data_dir)`
**Description**: Execute before_each.sh hook before each scenario
**Dependencies**: T008, T009
**Environment**: TC_SCENARIO, TC_DATA_DIR

### T020: Implement after_each.sh execution [Story: US1]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_after_each(suite_dir, scenario_name)`
**Description**: Execute after_each.sh hook after each scenario (always runs)
**Dependencies**: T008
**Logic**: Run even if scenario failed, log warnings on failure

### T021: Integrate hooks into scenario loop [Story: US1]
**File**: `tc/lib/core/executor.sh`
**Modify**: `tc_execute_suite()` scenario loop
**Description**: Add before_each/after_each around scenario execution
**Dependencies**: T019, T020
**Order**: before_each → run_scenario → after_each

### T022: Add hook execution timing [Story: US1] [P]
**File**: `tc/lib/core/hooks.sh`
**Description**: Add timing measurements to all hook executions
**Dependencies**: T008
**Output**: duration_ms in hook logs

### T023: Create database example suite structure [Story: US1] [P]
**File**: `examples/db-integration/`
**Description**: Create directory structure for PostgreSQL example
**Dependencies**: None
**Structure**:
```
examples/db-integration/
├── setup.sh
├── before_each.sh
├── teardown.sh
├── run
└── data/
    ├── create-user/
    ├── list-users/
    └── delete-user/
```

### T024: Write setup.sh for PostgreSQL example [Story: US1]
**File**: `examples/db-integration/setup.sh`
**Description**: Create test database, run migrations, save connection info
**Dependencies**: T023
**Logic**: From quickstart.md - create DB, run schema, write .tc-env

### T025: Write before_each.sh for PostgreSQL example [Story: US1]
**File**: `examples/db-integration/before_each.sh`
**Description**: Clear tables, seed baseline data
**Dependencies**: T023
**Logic**: TRUNCATE CASCADE, INSERT seed data

### T026: Write teardown.sh for PostgreSQL example [Story: US1]
**File**: `examples/db-integration/teardown.sh`
**Description**: Drop test database, cleanup
**Dependencies**: T023
**Logic**: DROP DATABASE, rm .tc-env

### T027: Write stateless runner for PostgreSQL example [Story: US1]
**File**: `examples/db-integration/run`
**Description**: Simple stateless runner for initial testing
**Dependencies**: T023
**Note**: Will be replaced with stateful runner in US2

### T028: Create test scenarios for database example [Story: US1] [P]
**Files**:
- `examples/db-integration/data/create-user/input.json`
- `examples/db-integration/data/create-user/expected.json`
- `examples/db-integration/data/list-users/input.json`
- `examples/db-integration/data/list-users/expected.json`
- `examples/db-integration/data/delete-user/input.json`
- `examples/db-integration/data/delete-user/expected.json`
**Description**: Create test input/output files
**Dependencies**: T023

### T029: Test setup.sh execution [Story: US1]
**Test**: Manual test - run setup.sh, verify database created
**Dependencies**: T017, T024
**Verification**: psql -l | grep tc_test_db

### T030: Test before_each.sh execution [Story: US1]
**Test**: Manual test - run before_each.sh, verify data seeded
**Dependencies**: T019, T025
**Verification**: psql query shows seed data

### T031: Test teardown.sh execution [Story: US1]
**Test**: Manual test - run teardown.sh, verify database dropped
**Dependencies**: T018, T026
**Verification**: Database no longer exists

### T032: Test full database suite [Story: US1]
**Test**: Run `tc examples/db-integration`
**Dependencies**: T021, T028
**Expected**: All 3 scenarios pass, database lifecycle works

### T033: Test hook failure - setup fails [Story: US1]
**Test**: Break setup.sh, verify suite aborts
**Dependencies**: T012, T017
**Expected**: Suite aborts, teardown still runs

### T034: Test hook failure - before_each fails [Story: US1]
**Test**: Break before_each.sh, verify scenario skipped
**Dependencies**: T012, T019
**Expected**: Scenario marked error, next scenario runs

### T035: Test hook failure - teardown fails [Story: US1]
**Test**: Break teardown.sh, verify logged but continues
**Dependencies**: T012, T018
**Expected**: Error logged, exit code 0

### T036: Verify database connection reuse [Story: US1]
**Test**: Add logging to setup.sh, verify runs only once
**Dependencies**: T032
**Expected**: "Connecting to database" logged once, not per test

### T037: Measure performance improvement [Story: US1]
**Test**: Compare stateless vs hook-based execution time
**Dependencies**: T032
**Expected**: Hook-based faster for 3+ tests

### T038: Create unit tests for hook functions [Story: US1] [P]
**File**: `tc/tests/unit/hooks/`
**Description**: Create tc test suite for hook functions
**Dependencies**: T017-T020
**Tests**: Hook discovery, validation, execution, failure handling

### T039: Add hook execution to status line [Story: US1] [P]
**File**: `tc/lib/utils/status-line.sh`
**Description**: Show hook execution in status line
**Dependencies**: T008
**Format**: `🚁 : RUNNING : suite/setup.sh ⠋`

### T040: Update help text with hooks info [Story: US1] [P]
**File**: `bin/tc`
**Function**: `show_help()`
**Description**: Add hooks section to help output
**Dependencies**: None

---

## Phase 4: US2 - Long-Running Test Runner (P1)

**User Story**: As a test framework user, I want tc to boot my test runner once and feed it multiple tests, so that expensive initialization only happens once.

**Independent Test**: Create stateful runner that accepts JSON commands via stdin, verify it handles multiple tests without restarting.

**Acceptance Criteria**:
- ✅ Runner process stays alive across multiple test scenarios
- ✅ tc feeds scenario names/data to runner via stdin
- ✅ Runner returns results per test
- ✅ Runner exits cleanly after all tests
- ✅ Falls back to current stateless mode if no setup hooks exist

### T041: Implement runner process spawning [Story: US2]
**File**: `tc/lib/core/runner.sh`
**Function**: `tc_start_stateful_runner(suite_dir)`
**Description**: Spawn long-running runner process with I/O redirection
**Dependencies**: T013
**Logic**: Start runner with stdin/stdout pipes, save PID

### T042: Implement JSON command sending [Story: US2]
**File**: `tc/lib/core/runner.sh`
**Function**: `tc_send_runner_command(runner_pid, command_json)`
**Description**: Send JSON command to runner's stdin
**Dependencies**: T041
**Protocol**: From contracts/runner-protocol.md

### T043: Implement JSON response receiving [Story: US2]
**File**: `tc/lib/core/runner.sh`
**Function**: `tc_receive_runner_response(runner_fd, timeout)`
**Description**: Read JSON response from runner's stdout with timeout
**Dependencies**: T041
**Logic**: `read -t $timeout`, validate JSON

### T044: Implement runner shutdown protocol [Story: US2]
**File**: `tc/lib/core/runner.sh`
**Function**: `tc_shutdown_stateful_runner(suite_dir)`
**Description**: Send shutdown command, wait for graceful exit, force kill if needed
**Dependencies**: T042
**Logic**: Send {"command":"shutdown"}, wait 5s, SIGTERM, wait 1s, SIGKILL

### T045: Implement runner PID tracking [Story: US2] [P]
**File**: `tc/lib/core/runner.sh`
**Description**: Save/load runner PID and FIFO paths
**Dependencies**: T041
**Files**: .tc-runner-pid, .tc-runner-fifo

### T046: Integrate stateful runner into executor [Story: US2]
**File**: `tc/lib/core/executor.sh`
**Modify**: `tc_execute_suite()`
**Description**: Detect stateful mode, use stateful runner for scenarios
**Dependencies**: T013, T041
**Logic**: If stateful mode, spawn runner after setup, use for all scenarios

### T047: Implement runner timeout handling [Story: US2]
**File**: `tc/lib/core/runner.sh`
**Description**: Kill runner if response timeout exceeded
**Dependencies**: T043
**Logic**: If read timeout, kill process, mark test as error

### T048: Implement runner crash detection [Story: US2]
**File**: `tc/lib/core/runner.sh`
**Description**: Detect if runner process exits unexpectedly
**Dependencies**: T041
**Logic**: Check if PID still alive before each command

### T049: Write stateful runner for PostgreSQL example [Story: US2]
**File**: `examples/db-integration/run`
**Description**: Replace stateless runner with stateful Ruby runner
**Dependencies**: T027
**Logic**: From quickstart.md - loop reading stdin, process commands

### T050: Test stateful runner spawning [Story: US2]
**Test**: Verify runner process starts and stays alive
**Dependencies**: T041, T049
**Verification**: Runner PID exists, accepts commands

### T051: Test JSON protocol - test command [Story: US2]
**Test**: Send TEST command, verify response received
**Dependencies**: T042, T043
**Expected**: Valid JSON response with status/output/duration_ms

### T052: Test JSON protocol - shutdown command [Story: US2]
**Test**: Send SHUTDOWN command, verify runner exits gracefully
**Dependencies**: T044
**Expected**: Runner exits with code 0

### T053: Test runner timeout [Story: US2]
**Test**: Create slow runner, verify timeout triggers
**Dependencies**: T047
**Expected**: Runner killed, test marked error

### T054: Test runner crash handling [Story: US2]
**Test**: Kill runner process mid-test, verify detection
**Dependencies**: T048
**Expected**: Remaining tests aborted, error logged

### T055: Test full stateful suite [Story: US2]
**Test**: Run `tc examples/db-integration` with stateful runner
**Dependencies**: T046, T049
**Expected**: All tests pass, runner started once

### T056: Verify runner state persistence [Story: US2]
**Test**: Add state to runner, verify persists across tests
**Dependencies**: T055
**Expected**: Database connection stays open, state maintained

---

## Phase 5: US3 - Per-Suite Hooks (P2)

**User Story**: As a test suite author, I want different lifecycle hooks per test suite, so that each suite can manage its own resources.

**Independent Test**: Create two suites with different hooks, verify each executes its own hooks independently.

**Acceptance Criteria**:
- ✅ Each suite can have its own setup/teardown/before_each/after_each
- ✅ Hooks are optional (stateless mode still works)
- ✅ Hooks run in correct order
- ✅ Hook failures abort the suite

**Note**: Most functionality already implemented in US1. These tasks add validation and logging.

### T057: Add per-suite hook configuration validation [Story: US3]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_validate_suite_hooks(suite_dir)`
**Description**: Validate all hooks in suite directory
**Dependencies**: T007
**Validation**: Check each hook file if present

### T058: Add per-suite hook discovery report [Story: US3] [P]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_report_discovered_hooks(suite_dir)`
**Description**: Log which hooks were discovered for suite
**Dependencies**: T005
**Output**: Debug log listing found hooks

### T059: Test multiple suites with different hooks [Story: US3]
**Test**: Create 2 suites, one with setup/teardown, one with before_each/after_each
**Dependencies**: T057
**Expected**: Each suite runs its own hooks independently

### T060: Test suite without hooks [Story: US3]
**Test**: Create suite with no hooks, verify stateless mode works
**Dependencies**: T013
**Expected**: Suite runs in stateless mode, no hook attempts

---

## Phase 6: US4 - Global Hooks (P3)

**User Story**: As a project with shared test infrastructure, I want global hooks that run for all test suites, so that I can manage shared resources (test DB, Docker, etc.).

**Independent Test**: Create global_setup.sh and global_teardown.sh, run multiple suites with --all, verify global hooks run once.

**Acceptance Criteria**:
- ✅ Global hooks in `tests/.tc/hooks/` directory
- ✅ Run before/after ALL test suites when using `tc tests --all`
- ✅ Per-suite hooks still work independently
- ✅ Global + per-suite hooks compose correctly

### T061: Implement global hook discovery [Story: US4]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_discover_global_hooks(test_root)`
**Description**: Check for global_setup.sh and global_teardown.sh
**Dependencies**: T006
**Location**: `$test_root/.tc/hooks/`

### T062: Implement global setup execution [Story: US4]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_global_setup(test_root)`
**Description**: Execute global_setup.sh before all suites
**Dependencies**: T061
**Environment**: TC_ROOT, TC_HOOK_TYPE=global_setup

### T063: Implement global teardown execution [Story: US4]
**File**: `tc/lib/core/hooks.sh`
**Function**: `tc_run_global_teardown(test_root)`
**Description**: Execute global_teardown.sh after all suites (always runs)
**Dependencies**: T061
**Logic**: Use trap to ensure runs even on failures

### T064: Integrate global hooks into --all flag [Story: US4]
**File**: `bin/tc`
**Modify**: `tc_run_all_suites()`
**Description**: Add global hooks to --all execution flow
**Dependencies**: T062, T063
**Order**: global_setup → suites (with their hooks) → global_teardown

### T065: Create global hooks directory [Story: US4] [P]
**File**: `tests/.tc/hooks/`
**Description**: Create standard location for global hooks
**Dependencies**: None

### T066: Create global hooks example [Story: US4]
**Files**:
- `examples/global-hooks/tests/.tc/hooks/global_setup.sh`
- `examples/global-hooks/tests/.tc/hooks/global_teardown.sh`
**Description**: Example showing Docker/PostgreSQL startup/shutdown
**Dependencies**: T065

### T067: Test global hooks execution [Story: US4]
**Test**: Create global hooks, run `tc tests --all`
**Dependencies**: T064, T066
**Expected**: Global hooks run once, per-suite hooks run per suite

### T068: Test global + per-suite hook composition [Story: US4]
**Test**: Verify execution order with both global and suite hooks
**Dependencies**: T067
**Expected**: global_setup → suite setup → tests → suite teardown → global_teardown

---

## Phase 7: Polish & Integration

**Goal**: Documentation, dogfooding, performance validation, backward compatibility.

### T069: Update README with hooks documentation [P]
**File**: `README.md`
**Description**: Add lifecycle hooks section with examples
**Dependencies**: T040

### T070: Create hooks documentation [P]
**File**: `docs/lifecycle-hooks.md`
**Description**: Comprehensive guide to using hooks
**Dependencies**: All user stories complete
**Sections**: Quickstart, hook types, examples, troubleshooting

### T071: Add dogfooding test suite [P]
**File**: `tc/tests/integration/hooks/`
**Description**: tc tests itself using hooks
**Dependencies**: T038
**Purpose**: Validate hooks work with tc's own tests

### T072: Run backward compatibility tests
**Test**: Run all existing tc tests, verify no breakage
**Dependencies**: All core tasks complete
**Expected**: All existing tests pass unchanged

### T073: Measure and document performance improvements
**Test**: Benchmark database testing with/without hooks
**Dependencies**: T037
**Output**: Performance comparison in docs

### T074: Final integration test
**Test**: Run all examples (hello-world, db-integration, global-hooks)
**Dependencies**: All tasks complete
**Expected**: All examples pass

---

## Dependency Graph

```
Setup (T001-T004)
    ↓
Foundational (T005-T016) [BLOCKING - must complete before user stories]
    ↓
    ├─→ US1: Database Testing (T017-T040) [MVP] ← Start here
    │       Tests independently: PostgreSQL suite
    │
    ├─→ US2: Stateful Runners (T041-T056)
    │       Depends on: US1 (uses hooks)
    │       Tests independently: Stateful runner protocol
    │
    ├─→ US3: Per-Suite Validation (T057-T060)
    │       Depends on: US1
    │       Tests independently: Multiple suites with different hooks
    │
    └─→ US4: Global Hooks (T061-T068)
            Depends on: US1
            Tests independently: Global hooks with --all flag
    ↓
Polish & Integration (T069-T074)
```

---

## Parallel Execution Opportunities

**Setup Phase** (all tasks can run in parallel):
- T001, T002, T003, T004 [P]

**Foundational Phase** (some tasks can run in parallel):
- T005, T006, T009, T010 [P] (discovery & env)
- After foundation: T007 (validation)
- After T007: T008 (execution wrapper)
- After T008: T011, T012, T013 [P] (logging, failure, detection)
- After T012: T014, T015, T016 (integration)

**US1 Phase** (examples and tests can parallelize with implementation):
- Implementation: T017-T022 (sequential - modify same module)
- Examples: T023-T028 [P] (create files in parallel)
- Tests: T029-T040 [P] after implementation complete

**US2 Phase** (similar pattern):
- Implementation: T041-T048 (sequential)
- Example: T049 (depends on implementation)
- Tests: T050-T056 [P] after T049

**US3 Phase** (small, mostly tests):
- T057, T058, T059, T060 - sequential (quick)

**US4 Phase**:
- T061-T064 (implementation, sequential)
- T065, T066 [P] (examples)
- T067, T068 [P] (tests)

**Polish Phase** (all can run in parallel):
- T069, T070, T071 [P] (documentation & tests)
- T072, T073, T074 [P] after all user stories complete

---

## Implementation Strategy

### MVP Scope (Minimum Viable Product)

**Focus**: User Story 1 (Database Testing Pattern) - 24 tasks
**Timeline**: ~2 days
**Deliverable**: Working setup/teardown/before_each/after_each hooks with PostgreSQL example

**MVP Tasks**: T001-T040
**MVP Test**: Run `tc examples/db-integration`, all 3 database tests pass

### Incremental Delivery

**Iteration 1** (MVP): US1 - Basic hooks
**Iteration 2**: US2 - Stateful runners (performance boost)
**Iteration 3**: US3 - Per-suite validation (quality)
**Iteration 4**: US4 - Global hooks (advanced feature)
**Iteration 5**: Polish & docs

### Testing Strategy

**Unit Tests**: Hook functions in isolation (T038)
**Integration Tests**: Full database suite (T032, T055)
**Manual Tests**: Each user story has independent test criteria
**Dogfooding**: tc tests itself with hooks (T071)
**Backward Compatibility**: All existing tests still pass (T072)

---

## Task Execution Checklist

When implementing each task:
- [ ] Read task description and dependencies
- [ ] Check all dependencies are complete
- [ ] Write code per specification
- [ ] Test locally (run affected tests)
- [ ] Update task status (Pending → In Progress → Complete)
- [ ] Commit with descriptive message
- [ ] Move to next task

When completing each user story:
- [ ] Run independent test criteria
- [ ] Verify acceptance criteria met
- [ ] Create checkpoint commit
- [ ] Update user story status in tasks.md

---

## Notes

- **Backward Compatibility**: All tasks preserve existing stateless behavior (hooks opt-in via file presence)
- **Zero Dependencies**: No new external dependencies (bash, jq, POSIX tools only)
- **Dogfooding**: tc will test itself using hooks (validates feature works)
- **Performance Goal**: Database testing ~15% faster with hooks vs stateless mode
- **Documentation**: Each user story includes working examples and tests

**Status**: Ready for implementation 🚁

**Next Step**: Start with MVP (US1) - Run `/speckit.implement` to execute tasks T001-T040.
