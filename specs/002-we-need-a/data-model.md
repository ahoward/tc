# Data Model: Test Suite Generator

**Date**: 2025-10-12
**Feature**: Test Suite Generator
**Plan**: [plan.md](plan.md) | **Research**: [research.md](research.md)

## Overview

The test suite generator works with three primary entities: Template Definitions, Generation Parameters, and Generated Test Suite Structures. These are represented as file system structures and bash data structures (associative arrays/variables).

## Entities

### 1. Template Definition

Represents a reusable pattern for generating test suites.

**Attributes**:
- `name`: Template identifier (e.g., "default", "hello-world")
- `location`: File system path to template files
- `type`: "builtin" or "example"
- `files`: Array of template files to process

**File Structure**:
```
templates/{name}/
├── run.template         # Executable test runner template
├── README.template      # Metadata documentation template
├── input.template       # Sample input JSON template
└── expected.template    # Sample expected output template
```

**Validation Rules**:
- Template name must be valid directory name
- All template files must exist
- Templates use variable placeholders: `${VAR_NAME}`

**State Transitions**:
- **Discovered** → when found during template listing
- **Selected** → when chosen for generation (default or --from flag)
- **Processed** → when instantiated with actual values

### 2. Generation Parameters

Input parameters for creating a new test suite.

**Attributes**:
- `test_path`: Target path for new test suite (required)
- `test_name`: Basename of path (derived from test_path)
- `template`: Template to use (default: "default")
- `tags`: Optional array of metadata tags
- `description`: Optional test description
- `priority`: Optional priority level (default: "medium")
- `dependencies`: Optional array of dependencies
- `force`: Boolean flag to overwrite existing (default: false)

**Validation Rules**:
- `test_path` must be non-empty
- `test_name` must match pattern: `^[a-z0-9][a-z0-9-]*[a-z0-9]$`
- `test_path` parent directories must be creatable
- If target exists, `force` must be true or error

**Derived Fields**:
- `test_name`: `basename "$test_path"`
- `parent_dir`: `dirname "$test_path"`
- `run_when`: Derived from path segments (e.g., "testing auth" from "tests/auth/login")

**Example**:
```bash
# Input
test_path="tests/auth/login"
tags=("auth" "api" "security")
priority="high"

# Derived
test_name="login"
parent_dir="tests/auth"
run_when="testing auth"
```

### 3. Generated Test Suite Structure

The output file/directory structure created by the generator.

**Structure**:
```
{test_path}/
├── run                      # Executable test runner (chmod +x)
├── README.md                # Metadata documentation
└── data/                    # Test data directory
    └── example-scenario/    # First scenario
        ├── input.json       # Sample input
        └── expected.json    # Sample expected output
```

**File Contents**:

**`run` (executable bash script)**:
```bash
#!/usr/bin/env bash
# ${test_name} test runner
# Generated by tc new
# TODO: Implement test logic

set -e

input_file="$1"

# TODO: Parse input
# Example: value=$(jq -r '.field' "$input_file")

# TODO: Implement test logic
# Example: result=$(your_command_here)

# For now, return NOT_IMPLEMENTED error
cat <<'EOF'
{
  "error": "NOT_IMPLEMENTED",
  "message": "Test logic not yet implemented. Edit this 'run' script to add your implementation.",
  "next_steps": [
    "1. Parse input.json using jq or your preferred method",
    "2. Execute the code/feature you're testing",
    "3. Format output as JSON matching expected.json structure",
    "4. Run 'tc run ${test_path}' to verify"
  ]
}
EOF

exit 1
```

**`README.md` (metadata documentation)**:
```markdown
# ${test_name}

**tags**: \`pending\`, \`new\`${extra_tags}
**what**: ${description}
**depends**: ${dependencies}
**priority**: ${priority}

## description

TODO: Add detailed description of what this test validates.

Key areas to document:
- What feature/functionality is being tested
- What inputs are expected
- What outputs should be produced
- Any special setup or prerequisites

## scenarios

- \`example-scenario\` - TODO: Describe what this scenario tests

## ai notes

run this when: ${run_when}
skip this when: test logic not yet implemented (pending)
after this: TODO: List related tests to run after this passes

## next steps

1. Edit the \`run\` script to implement test logic
2. Update \`data/example-scenario/input.json\` with realistic test data
3. Update \`data/example-scenario/expected.json\` with expected output
4. Add more scenarios by creating new directories under \`data/\`
5. Run \`tc run ${test_path}\` to verify implementation
6. Update this README with actual test details
```

**`data/example-scenario/input.json`**:
```json
{
  "TODO": "Replace this with actual input data for your test",
  "example_field": "example_value"
}
```

**`data/example-scenario/expected.json`**:
```json
{
  "TODO": "Replace this with expected output for your test",
  "example_result": "expected_value"
}
```

**Validation Rules**:
- `run` script must be executable
- All JSON files must be valid JSON
- README must contain required metadata fields
- Directory structure must match tc expectations

### 4. Generation Result

Metadata about the generation operation.

**Attributes**:
- `success`: Boolean indicating success/failure
- `created_path`: Absolute path to created test suite
- `files_created`: Array of created file paths
- `template_used`: Name of template that was applied
- `timestamp`: Generation timestamp

**State**:
- **Success**: All files created, structure valid, ready to edit
- **Partial**: Some files created but errors occurred
- **Failed**: No files created, error prevented generation

## Relationships

```
Generation Parameters
    |
    | selects
    v
Template Definition
    |
    | instantiates with parameters
    v
Generated Test Suite Structure
    |
    | produces
    v
Generation Result
```

## Data Flow

1. **Input Collection**:
   ```
   User Command → Parse Arguments → Generation Parameters
   ```

2. **Template Selection**:
   ```
   Generation Parameters → Select Template → Template Definition
   ```

3. **Validation**:
   ```
   Generation Parameters → Validate (name, path, conflicts)
   Template Definition → Validate (files exist, readable)
   ```

4. **Generation**:
   ```
   Template Definition + Generation Parameters → Process Variables → Create Files
   ```

5. **Post-Generation**:
   ```
   Generated Structure → Validate → Generation Result → Display Summary
   ```

## Example Flow

```bash
# User command
$ tc new tests/auth/login --tags "auth,api" --priority high

# Parsed parameters
{
  test_path: "tests/auth/login"
  test_name: "login"
  template: "default" (default value)
  tags: ["auth", "api"]
  priority: "high"
}

# Template selected
{
  name: "default"
  location: "/path/to/tc/lib/templates/default"
  type: "builtin"
  files: ["run.template", "README.template", "input.template", "expected.template"]
}

# Variables for substitution
{
  TEST_NAME: "login"
  TEST_PATH: "tests/auth/login"
  EXTRA_TAGS: ", `auth`, `api`"
  DESCRIPTION: "TODO: describe test purpose"
  PRIORITY: "high"
  DEPENDENCIES: ""
  RUN_WHEN: "testing auth"
}

# Generated structure
tests/auth/login/
├── run (executable)
├── README.md
└── data/
    └── example-scenario/
        ├── input.json
        └── expected.json

# Result
{
  success: true
  created_path: "/absolute/path/to/tests/auth/login"
  files_created: ["run", "README.md", "data/example-scenario/input.json", ...]
  template_used: "default"
  timestamp: "2025-10-12T12:34:56Z"
}
```

## Storage

**File System**:
- Templates: `lib/templates/`
- Generated suites: User-specified path (e.g., `tests/auth/login`)
- No database or persistence layer needed

**Runtime Only**:
- Generation parameters (bash variables)
- Template definitions (discovered at runtime)
- Generation result (displayed and discarded)

## Edge Cases

1. **Nested Path Creation**:
   - Input: `tests/api/v2/auth/login`
   - Action: Create all parent directories with `mkdir -p`
   - Validation: Check write permissions before creation

2. **Existing Directory**:
   - Input: Path that already exists
   - Action: Error unless `--force` flag provided
   - Validation: Check existence before starting generation

3. **Invalid Characters**:
   - Input: `My Test` (space), `Test_Suite` (underscore)
   - Action: Reject with clear error message
   - Validation: Regex check before any file operations

4. **Permission Denied**:
   - Input: Path in read-only directory
   - Action: Fail gracefully with clear error
   - Validation: Test write permissions with `mkdir -p`

5. **Empty or Root Path**:
   - Input: `.` or `/`
   - Action: Reject as invalid
   - Validation: Require non-empty, relative-safe path

