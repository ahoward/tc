# Technical Research: Test-Kit Implementation Decisions

**Feature**: Test-Kit Integration with Spec-Kit
**Phase**: 0 - Research & Technical Decisions
**Date**: 2025-10-18

## Overview

This document resolves all "NEEDS CLARIFICATION" items from the planning phase and establishes concrete technical decisions for implementing tc-kit's slash commands.

---

## Decision 1: Markdown Parsing Strategy

**Problem**: How to extract user stories and acceptance criteria from spec.md markdown files?

**Decision**: Use grep/sed/awk pattern matching with explicit markdown structure conventions

**Rationale**:
- Spec-kit already enforces structured markdown (## User Scenarios, ### User Story N, **Acceptance Scenarios**)
- Avoids heavyweight markdown parser dependencies (maintains POSIX compatibility)
- Leverages existing patterns in spec-kit ecosystem
- Fast and deterministic (no AI inference needed)

**Implementation Approach**:
```bash
# Extract user story titles
grep -E "^### User Story [0-9]+" spec.md

# Extract acceptance scenarios (Given/When/Then)
sed -n '/^**Acceptance Scenarios**:/,/^---/p' spec.md | grep -E "^\s*[0-9]+\.\s+\*\*Given\*\*"

# Parse priority from titles
grep -oP 'Priority:\s+P\d+' spec.md
```

**Alternatives Considered**:
- **Pandoc/markdown parser**: Rejected - adds external dependency, overkill for structured input
- **AI extraction**: Rejected - non-deterministic, slower, requires API/model
- **Custom parser in jq**: Rejected - markdown isn't JSON-friendly

---

## Decision 2: Pattern Mapping Heuristics

**Problem**: When generating expected.json, how to decide which tc pattern (`<uuid>`, `<timestamp>`, `<string>`, etc.) to use?

**Decision**: Rule-based heuristics with explicit keywords in acceptance criteria

**Pattern Selection Rules**:
1. **Explicit mentions**: If "UUID", "unique ID", "identifier" → `<uuid>`
2. **Time keywords**: If "timestamp", "created_at", "date", "time" → `<timestamp>`
3. **Numeric keywords**: If "count", "total", "number", "quantity" → `<number>`
4. **Boolean keywords**: If "enabled", "active", "is_valid", "success" → `<boolean>`
5. **Null keywords**: If "null", "missing", "absent", "empty" → `<null>`
6. **Default**: Everything else → `<string>` (most permissive)

**Example Mapping**:
```
Given/When/Then: "system returns a unique identifier"
→ expected.json: {"id": "<uuid>"}

Given/When/Then: "response includes creation timestamp"
→ expected.json: {"created_at": "<timestamp>"}

Given/When/Then: "status is pending"
→ expected.json: {"status": "pending"}  # Exact match (specific value stated)
```

**Rationale**:
- Deterministic and reviewable by humans
- Encourages clear acceptance criteria wording
- Easily extended with TC_CUSTOM_PATTERNS for domain-specific patterns
- Falls back to `<string>` safely when uncertain

**Alternatives Considered**:
- **AI/LLM inference**: Rejected - non-deterministic, requires external service
- **Always use `<any>`**: Rejected - too permissive, defeats pattern matching value
- **Manual annotation in specs**: Rejected - adds friction to spec writing

---

## Decision 3: Directory Naming Convention

**Problem**: Exact format for generated test directories (hyphens, underscores, numbering)?

**Decision**: Kebab-case with zero-padded numeric suffixes

**Format**:
```
tc/tests/{feature-name}/user-story-{NN}/scenario-{NN}/
```

**Examples**:
```
tc/tests/008-explore-the-strategy/user-story-01/scenario-01/
tc/tests/user-authentication/user-story-03/scenario-02/
```

**Rationale**:
- **Kebab-case**: URL-safe, shell-friendly, human-readable
- **Zero-padded**: Natural sort order (user-story-01 before user-story-10)
- **Explicit labels**: Self-documenting (vs `us01`, `s02`)
- **Feature-rooted**: Matches spec directory structure (Clarification §2025-10-18)

**Numbering Rules**:
- User stories: Extract from "User Story N" (N → zero-pad to 2 digits)
- Scenarios: Sequential 01, 02, 03 within each user story
- Feature names: Use spec directory name as-is (e.g., `008-explore-the-strategy`)

**Alternatives Considered**:
- **Snake_case**: Rejected - inconsistent with existing tc conventions
- **CamelCase**: Rejected - harder to read, shell-unfriendly
- **No zero-padding**: Rejected - breaks natural sort

---

## Decision 4: Run Script Template

**Problem**: What should generated `run` scripts contain for NOT_IMPLEMENTED state?

**Decision**: Minimal POSIX-compliant shell script with clear NOT_IMPLEMENTED message

**Template**:
```bash
#!/usr/bin/env bash
# Auto-generated by tc-kit from spec: {spec-path}
# User Story: {user-story-title}
# Scenario: {scenario-number}
# Traceability: {spec-ref}

set -euo pipefail

# Read input from stdin (tc contract)
input=$(cat)

# NOT_IMPLEMENTED: Replace this block with actual implementation
echo '{"error": "NOT_IMPLEMENTED", "message": "Test runner not yet implemented"}' >&2
exit 1

# Expected behavior (from spec):
# {Given/When/Then text}
```

**Rationale**:
- **POSIX-compatible**: Works in all Bash 4.0+ environments
- **Explicit failure**: Clear "NOT_IMPLEMENTED" error when tests run
- **Self-documenting**: Includes spec reference and expected behavior
- **tc-compatible**: Follows tc's stdin→stdout contract
- **Exit 1**: Ensures tests fail until implemented

**Alternatives Considered**:
- **Language-specific templates (Python, Go)**: Rejected - violates language-agnostic principle
- **Empty script**: Rejected - unclear why test fails
- **Skip/ignore scripts**: Rejected - defeats TDD purpose

---

## Decision 5: Traceability JSON Schema

**Problem**: How to structure traceability.json for bidirectional spec↔test links?

**Decision**: Dual-index structure with forward (spec→tests) and reverse (test→spec) maps

**Schema**:
```json
{
  "version": "1.0",
  "feature": "008-explore-the-strategy",
  "spec_path": "/absolute/path/to/spec.md",
  "generated_at": "2025-10-18T12:34:56Z",
  "forward": {
    "user-story-1": {
      "title": "Spec-First Test Creation",
      "priority": "P1",
      "scenarios": {
        "scenario-1": "tc/tests/008-explore-the-strategy/user-story-01/scenario-01",
        "scenario-2": "tc/tests/008-explore-the-strategy/user-story-01/scenario-02"
      }
    }
  },
  "reverse": {
    "tc/tests/008-explore-the-strategy/user-story-01/scenario-01": {
      "spec_ref": "user-story-1.scenario-1",
      "user_story": "Spec-First Test Creation",
      "given_when_then": "Given a spec-kit specification..."
    }
  }
}
```

**Rationale**:
- **Dual-index**: O(1) lookup in both directions (spec→test, test→spec)
- **Absolute paths**: Survives directory moves
- **Version field**: Enables schema evolution
- **Timestamp**: Track when mapping was generated
- **Self-contained**: All traceability data in single file

**Alternatives Considered**:
- **Single direction only**: Rejected - requires reverse search for validation
- **Embedded in test files**: Rejected - harder to query full coverage matrix
- **Database**: Rejected - adds dependency, violates "rm -rf tests safe" requirement

---

## Decision 6: Maturity Level Tracking

**Problem**: How to track and detect test maturity transitions (concept→exploration→implementation)?

**Decision**: maturity.json with signal detection + explicit override flags

**Schema**:
```json
{
  "version": "1.0",
  "suites": {
    "tc/tests/008-explore-the-strategy/user-story-01/scenario-01": {
      "maturity_level": "concept",
      "detected_signals": {
        "has_implementation": false,
        "passing_runs": 0,
        "last_modified": "2025-10-18T12:00:00Z",
        "pattern_types": ["<uuid>", "<timestamp>", "<string>"]
      },
      "manual_override": null
    }
  },
  "transition_rules": {
    "concept_to_exploration": "First implementation commit detected",
    "exploration_to_implementation": "5+ consecutive passing runs"
  }
}
```

**Signal Detection Logic**:
```bash
# Concept → Exploration signals:
- run script modified beyond template
- first git commit touching run script
- any passing test result

# Exploration → Implementation signals:
- 5+ consecutive passing test runs
- pattern usage decreased (more exact values)
- custom assertions added beyond patterns
```

**Rationale**:
- **Hybrid approach**: Matches Clarification §2025-10-18 (detect + explicit control)
- **Signal history**: Audit trail for maturity transitions
- **Manual override**: Teams can force level with `--level` flag
- **Transition rules documented**: Clear criteria in metadata

**Alternatives Considered**:
- **Git-only detection**: Rejected - not all teams use git consistently
- **Manual-only**: Rejected - adds friction, teams may forget
- **Automatic transitions**: Rejected - violates explicit control requirement

---

## Decision 7: Error Handling Strategy

**Problem**: How to handle malformed specs, partial failures, edge cases?

**Decision**: Fail-fast with detailed error messages, partial success supported

**Error Categories**:
1. **Fatal errors** (stop generation):
   - spec.md not found
   - No user stories detected
   - Malformed JSON in traceability (corruption)

2. **Recoverable errors** (warn + continue):
   - Individual scenario parsing failures → log warning, skip scenario
   - Ambiguous acceptance criteria → generate multiple test variants with warnings
   - Duplicate scenario names → append suffix `-variant-N`

3. **Edge cases** (documented behavior):
   - Empty specs → generate empty traceability, warn user
   - Non-JSON-testable criteria → generate placeholder with TODO comment
   - Missing Given/When/Then → generate from title only, mark as "INCOMPLETE"

**Error Output Format**:
```bash
# Fatal error (exit 1)
ERROR: spec.md not found at {path}

# Recoverable error (exit 0, partial success)
WARNING: Failed to parse scenario 3 in user-story-2: {reason}
Generated 5 of 6 scenarios successfully

# Edge case notification
NOTICE: Scenario requires non-JSON testing (UI interaction)
Generated placeholder test with manual implementation required
```

**Rationale**:
- **Fail-fast on fatal**: Prevents corrupted state
- **Partial success**: Teams can proceed with most tests while fixing edge cases
- **Clear categorization**: Users know whether action required
- **Detailed messages**: Include context (which scenario, what failed, why)

**Alternatives Considered**:
- **Strict mode only**: Rejected - too rigid for iterative spec development
- **Silent failures**: Rejected - teams won't notice missing tests
- **Automatic fixes**: Rejected - unpredictable, hides spec quality issues

---

## Decision 8: TTY Detection & Output Modes

**Problem**: How to implement dual output (TTY vs non-TTY) for validation reports?

**Decision**: Reuse tc's existing TTY detection logic, add markdown rendering for TTY

**Implementation**:
```bash
# Reuse tc's TTY detection
if [ -t 1 ] && [ "${TC_FANCY_OUTPUT:-auto}" != "false" ]; then
  # TTY mode: Rich markdown with colors
  render_markdown_report
else
  # Non-TTY mode: Plain text summary
  output_json_only
fi

# Always persist JSON
write_json_report ./tc/spec-kit/validation-report.json
```

**Output Formats**:
- **TTY**: Colored markdown tables, emoji indicators (✅ ❌ ⚠️), progress bars
- **Non-TTY**: Plain text summary + JSON file path
- **JSON file**: Always written to `./tc/spec-kit/validation-report.json`

**Rationale**:
- **Consistency**: Matches tc framework's existing behavior
- **CI-friendly**: JSON output parseable by CI tools
- **Human-friendly**: Rich terminal output for interactive use
- **Persistent audit trail**: JSON file always available for review

**Alternatives Considered**:
- **Always JSON to stdout**: Rejected - poor UX for interactive use
- **Separate flags**: Rejected - inconsistent with tc conventions
- **Markdown-only**: Rejected - not CI/script-friendly

---

## Summary of Decisions

| Decision Area | Choice | Key Rationale |
|---------------|--------|---------------|
| **Markdown Parsing** | grep/sed/awk patterns | POSIX-compatible, deterministic, no external deps |
| **Pattern Mapping** | Rule-based keywords | Deterministic, encourages clear specs |
| **Directory Naming** | Kebab-case + zero-pad | Shell-friendly, natural sort |
| **Run Scripts** | Minimal POSIX template | Language-agnostic, explicit failure |
| **Traceability** | Dual-index JSON | O(1) bidirectional lookup |
| **Maturity Tracking** | Signal detection + manual | Hybrid control (Clarification match) |
| **Error Handling** | Fail-fast + partial success | Balance strictness with flexibility |
| **TTY Detection** | Reuse tc's logic | Consistency with existing framework |

**Next Phase**: Phase 1 - Data model, contracts, and quickstart documentation
